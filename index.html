<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Иллюстрация растровых алгоритмов + OpenCV</title>
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #FADADD, #FFF0F5);
    font-family: "Segoe UI", sans-serif;
    color: #4B2E05;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin: 20px 0 10px;
    color: #C71585;
    font-size: 30px;
  }
  .controls {
    background: #fffafc;
    padding: 15px 25px;
    border-radius: 16px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
  }
  select, input {
    border: 1px solid #C71585;
    border-radius: 8px;
    padding: 4px 8px;
    font-size: 14px;
  }
  button {
    background-color: #C71585;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 7px 14px;
    font-size: 14px;
    cursor: pointer;
    transition: 0.3s;
  }
  button:hover {
    background-color: #d050a5;
    transform: scale(1.05);
  }
  button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
    transform: none;
  }
  canvas {
    background-color: #FFF;
    margin-top: 20px;
    border: 2px solid #C71585;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  #time {
    margin: 10px;
    font-weight: bold;
  }
  .info {
    background: #fff8f8;
    border: 1px solid #f0b6cc;
    border-radius: 12px;
    padding: 12px 20px;
    max-width: 800px;
    line-height: 1.5;
    margin-bottom: 30px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  .info h2 {
    margin-top: 0;
    color: #C71585;
  }
  .note {
    margin: 20px;
    font-size: 14px;
    max-width: 700px;
    color: #4B2E05;
  }
  #status {
    color: #C71585;
    font-weight: bold;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<h1>Иллюстрация растровых алгоритмов (OpenCV)</h1>

<div id="status">Загрузка OpenCV...</div>

<div class="controls">
  <label>Алгоритм:</label>
  <select id="algorithm">
    <option value="step">Пошаговый (OpenCV Line)</option>
    <option value="dda">ЦДА (OpenCV Line)</option>
    <option value="bresenham">Брезенхем (OpenCV Line)</option>
    <option value="circle">Брезенхем (OpenCV Circle)</option>
    <option value="bezier">Кастла–Питвея (JS Math)</option>
    <option value="wu">Сглаженная линия (OpenCV AA)</option>
  </select>
  <label>X₁: <input type="number" id="x1" value="-10"></label>
  <label>Y₁: <input type="number" id="y1" value="-5"></label>
  <label>X₂: <input type="number" id="x2" value="10"></label>
  <label>Y₂: <input type="number" id="y2" value="8"></label>
  <button id="btnDraw" onclick="draw()" disabled>Построить</button>
  <button onclick="clearCanvas()">Очистить</button>
</div>

<div id="time">Среднее время выполнения: —</div>

<canvas id="canvas" width="800" height="800"></canvas>

<div class="info" id="desc"></div>

<div class="note">
<b>Примечание:</b>  
Используется библиотека <b>OpenCV.js</b> для растеризации примитивов на виртуальной сетке, после чего результат переносится на холст.
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const size = 20;
const midX = Math.floor(canvas.width / 2);
const midY = Math.floor(canvas.height / 2);

const gridW = canvas.width / size; 
const gridH = canvas.height / size;
const offset = gridW / 2; 

let cvReady = false;

function onOpenCvReady() {
  cvReady = true;
  document.getElementById("status").innerText = "OpenCV готов к работе";
  document.getElementById("status").style.color = "green";
  document.getElementById("btnDraw").disabled = false;
}

function gridToCanvas(x, y) {
  return { cx: midX + x * size, cy: midY - y * size };
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#eee";
  ctx.lineWidth = 1;

  for (let x = midX % size; x <= canvas.width; x += size) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = midY % size; y <= canvas.height; y += size) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  ctx.strokeStyle = "#C71585";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, midY);
  ctx.lineTo(canvas.width, midY);
  ctx.moveTo(midX, 0);
  ctx.lineTo(midX, canvas.height);
  ctx.stroke();

  ctx.fillStyle = "#C71585";
  ctx.font = "12px Segoe UI";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  for (let i = -20; i <= 20; i++) {
    const { cx } = gridToCanvas(i, 0);
    if (i !== 0) ctx.fillText(i, cx, midY + 4);
  }
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  for (let j = -20; j <= 20; j++) {
    const { cy } = gridToCanvas(0, j);
    if (j !== 0) ctx.fillText(j, midX + 4, cy);
  }
}

function plot(x, y, color = "#C71585") {
  const { cx, cy } = gridToCanvas(x, y);
  ctx.fillStyle = color;
  ctx.fillRect(cx - size / 2 + 1, cy - size / 2 + 1, size - 2, size - 2);
}

function clearCanvas() {
  drawGrid();
}

function runOpenCV(drawCallback) {
    if (!cvReady) return [];

    let rows = gridH + 1; 
    let cols = gridW + 1;
    let mat = new cv.Mat.zeros(rows, cols, cv.CV_8UC1);

    drawCallback(mat);

    const points = [];
    let data = mat.data; 

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let intensity = data[r * cols + c];
            if (intensity > 0) {
                let x = c - Math.floor(cols/2);
                let y = Math.floor(rows/2) - r;
             
                if (intensity < 255) {
                    let alpha = intensity / 255;
                    points.push([x, y, `rgba(199,21,133,${alpha.toFixed(2)})`]);
                } else {
                    points.push([x, y]);
                }
            }
        }
    }
    
    mat.delete(); 
    return points;
}

function toCvPt(x, y) {
    const cx = Math.floor(gridW/2);
    const cy = Math.floor(gridH/2);
    return new cv.Point(x + cx, cy - y);
}

function cvLine(x1, y1, x2, y2) {
    return runOpenCV((mat) => {
        let p1 = toCvPt(x1, y1);
        let p2 = toCvPt(x2, y2);
        let color = new cv.Scalar(255);
        cv.line(mat, p1, p2, color, 1, cv.LINE_8);
    });
}

function cvWuLine(x1, y1, x2, y2) {
    return runOpenCV((mat) => {
        let p1 = toCvPt(x1, y1);
        let p2 = toCvPt(x2, y2);
        let color = new cv.Scalar(255);
        cv.line(mat, p1, p2, color, 1, cv.LINE_AA);
    });
}

function cvCircle(x0, y0, r) {
    return runOpenCV((mat) => {
        let center = toCvPt(x0, y0);
        let color = new cv.Scalar(255);
        cv.circle(mat, center, r, color, 1, cv.LINE_8);
    });
}

function bezierCurve(x1, y1, x2, y2) {
  const cx = (x1 + x2) / 2;
  const cy = (y1 + y2) / 2 + Math.sign(y2 - y1) * Math.abs(x2 - x1)/2;
  const points = [];
  for (let t = 0; t <= 1; t += 0.02) {
    const x = (1 - t) ** 2 * x1 + 2 * (1 - t) * t * cx + t ** 2 * x2;
    const y = (1 - t) ** 2 * y1 + 2 * (1 - t) * t * cy + t ** 2 * y2;
    points.push([Math.round(x), Math.round(y)]);
  }
  return points;
}

async function animatePoints(points) {
  for (let i = 0; i < points.length; i++) {
    const [x, y, color] = points[i];
    plot(x, y, color || "#C71585");
    await new Promise(r => setTimeout(r, 40));
  }
}

async function draw() {
  if (!cvReady) {
      alert("OpenCV еще загружается, подождите...");
      return;
  }

  clearCanvas();
  const algo = document.getElementById("algorithm").value;
  const x1 = parseFloat(document.getElementById("x1").value);
  const y1 = parseFloat(document.getElementById("y1").value);
  const x2 = parseFloat(document.getElementById("x2").value);
  const y2 = parseFloat(document.getElementById("y2").value);

  const runs = 10; 
  const t0 = performance.now();
  
  let points = [];
  
  for (let i = 0; i < runs; i++) {
    if (algo === "step" || algo === "dda" || algo === "bresenham") {
        points = cvLine(x1, y1, x2, y2);
    }
    else if (algo === "circle") points = cvCircle(x1, y1, 8); 
    else if (algo === "bezier") points = bezierCurve(x1, y1, x2, y2);
    else if (algo === "wu") points = cvWuLine(x1, y1, x2, y2);
  }
  
  const t1 = performance.now();
  const avg = (t1 - t0) / runs;
  clearCanvas();

  if (points.length > 0 && algo !== 'circle') {
      points.sort((a, b) => {
         let distA = (a[0]-x1)**2 + (a[1]-y1)**2;
         let distB = (b[0]-x1)**2 + (b[1]-y1)**2;
         return distA - distB;
      });
  }

  animatePoints(points);
  document.getElementById("time").innerText = 
    `Среднее время выполнения (OpenCV): ${avg.toFixed(5)} мс`;
  updateDescription(algo);
}

function updateDescription(algo) {
  const desc = document.getElementById("desc");
  const texts = {
    step: "<h2>Пошаговый / ЦДА / Брезенхем (OpenCV)</h2>Все эти алгоритмы заменены на <code>cv.line()</code> с типом LINE_8. OpenCV использует оптимизированный алгоритм Брезенхема внутри.",
    dda: "<h2>ЦДА (через OpenCV)</h2>Реализовано через <code>cv.line()</code>.",
    bresenham: "<h2>Брезенхем (через OpenCV)</h2>Используется стандартный <code>cv.line()</code>. Самый быстрый способ отрисовки линий.",
    circle: "<h2>Окружность (OpenCV)</h2>Используется <code>cv.circle()</code>. Генерирует 8-связную окружность на матрице.",
    bezier: "<h2>Кастла–Питвея (Безье)</h2>Оставлена нативная JS реализация, так как OpenCV использует полилинии для кривых.",
    wu: "<h2>Сглаженная линия (OpenCV AA)</h2>Используется <code>cv.line()</code> с флагом <code>cv.LINE_AA</code> (Gaussian filtering). Пиксели получают прозрачность."
  };
  desc.innerHTML = texts[algo] || texts['step'];
}

drawGrid();
updateDescription("step");
</script>

</body>
</html>
